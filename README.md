# C/C++学习过程记录

# learn_4
第四周的学习.
包括: 
- 1.数组学习.
- 2.三子棋,五子棋小游戏   game.c   and  game2.0
- 3.扫雷游戏  game3.0_mine   优化版本    game3.0_mine2.0	彩色printf输出,读取所用时间的应用
- 4.待优化类容:扫雷标记 下一次打印会清除上一次标记内容(该功能已优化)  新增定点清除标记功能	 
- 5.学习了操作符使用,结构体和指针.都是初阶.
- 6.初阶的测试,交换单词顺序,三次翻转法.
- 7.const int * p;  int * const p;区别.
- 8.#include <assert.h>  assert( p != NULL);空指针断言
- 9.扫雷标记功能优化,定点删除改为后面的坐标覆盖前面的坐标,容量-1,   待优化:无用输入缓存区清除.

# learn_5
第五周的学习
- 1. gitignore 的使用
- 2. 数据存储作业 int 型 float 型,不同类型在内存中的存储
- 3. 数据的类型不是关键 ,关键时看待内存的视角
- 4. 递归问题的思想:大事化小,问题拆分,逐渐接近,结束递归.
    其中,"问题拆分"是关键,只有复杂的问题拆分得"足够简单",一个单独的函数.
- 5. 递归实现多重for循环,使用return;结束递归.也可以结束循环
- 6.先整形提升,在进行运算.
- 7.指针进阶的学习	数组指针,函数指针,回调函数.空指针void*
- 8.模拟实现 qsort(void* p,size_t sz,size_t width,int(*cmp)(void*,void*))
- 9.指针进阶习题
- 10.字符串函数模拟实现, 内存函数模拟实现.	KMP算法

# learn_6
第6周学习
- 1.自定义类型学习:结构体,枚举,联合体
- 2.#define执行的是查找替换,不是整体,typedef是整体,新类型
- 3.牛客网题目作业.备注:写完代码最好去看看别人优秀的代码
- 4.通讯录功能实现	静态/动态空间开辟
- 5.动态内存管理 malloc realloc free NULL 暂时没用到 calloc
- 6.结构体,枚举,联合体;动态内存管理  作业
- 7.柔性数组 结构体指针
- 8.文件操作 FILE* pf = fopen("文件名","打开方式");	fclose(pf); pf = NULL;
- 9.通讯录3.0  文件读写操作
- 10.程序编译,预处理,编译,汇编,链接, #include <> "" ,#define宏定义 ,条件编译#if #endif
- 复杂代码:通讯录实现 贪吃蛇代码的实现

数据结构算法学习:
- 11.时间&空间复杂度
- 12.顺序表的学习

# learn_7
第七周学习
数据结构学习
- 1.顺序表 
- 2.单链表
- 3.oj题目:翻转链表,循环链表入口节点,链表排序,判断回文链表,拷贝链表(复杂/简单),找链表相交点
快慢指针使用,利用画图和数学推演
- 4.记住: 慢就是快. 这类题目代码不是关键,思路和画图才是关键.
把图画的仔细,开始条件,循环单元,结束条件,具体的变量命名.越仔细,调试代码耗时越短.
- 5.带头双向循环链表;
- 6.栈和队列 栈==>后进先出,数组实现; 队列==>先进先出,链表实现
- 7.判断括号合法性==>栈;利用2个队列实现栈;利用2个栈实现队列;循环队列
- 8.二叉树
- 9.堆实现,大堆,小堆,堆排序N*logN,堆插入,堆构建,向下调整算法,向上调整算法.
```
堆排序,最值移动到最后,忽略他,继续建堆,选出新的最值,重复;
TopK问题,建立一个K个数的堆.求最小值就建立大堆;求最大值就建立小堆;
堆顶是看门狗,比他还大/小就替换他,进堆;
```
- 10.求总节点个数,求叶节点个数,求最大深度: 通过递归返回值实现更优

核心:大问题拆分为小问题,递归实现.递归结束条件,问题不能在拆分了.
接口函数:为了避免局部变量销毁,使用static 或者 malloc.


# learn_8
第8周的学习 数据结构初阶 后1/3 开始linux和cpp的并行学习

- 1.二叉树oj :
```
翻转二叉树(二叉树的镜像),另一棵树的子树,相同的树,平衡二叉树
二叉树的前序遍历     二叉树的中序遍历     二叉树的后序遍历   二叉树的最大深度
二叉树的层序遍历(队列)	单值二叉树   二叉树的深度   判断对称二叉树
复制二叉树   销毁复制的树(销毁二叉树)	二叉树遍历(字符串转二叉树)   二叉树查找
判断一颗树是否是完全二叉树     二叉树第k层节点个数
```
- 2.问题拆分,把问题转化为左子树和右子树的问题,然后画图分析+代码;
在画图和代码框架的过程中,理解递归的思想,实现代码;
当问题不能在拆分下去,就是递归结束的条件;
- 3.排序
```
插入排序:直接插入排序 	希尔排序
选择排序:直接选择排序	堆排序
交换排序:冒泡排序		快速排序
以上再内存上排序;
归并排序:可以再内存和外存上排序 
```
- 4.笔记整理,知识点细节有点多,在博客上梳理核心+1
- 5.开始linux和cpp的并行学习,服务器centos7

linux基础指令学习:
```
ls cd nano grep find tree cal echo | < >> cat tac adduser passwd 
yum zip unzip tar more less head tail history touch mkdir rm rmdir xargs ./ dc date ssh su - gcc 
```

- 6.cpp基础学习:命名空间,函数重载,引用学习
```
内联函数inline auto 类(对象)struct class 访问限定符:public private protected
头文件:extern int a;//声明 static int a;//定义,链接属性仅当前文件,不同文件各自一个
extern "C"配合条件编译==>CPP和C互相调用
```

- 7.类(对象):
```
构造函数->对象实例化时初始化成员变量(全缺省/无参数构造);
析构函数->对象销毁时清除成员变量(比如释放malloc,fopen指针)
拷贝构造函数->拷贝对象(传引用,防止无穷递归)
自定义拷贝构造,赋值运算符重载;默认生成==>只能浅拷贝;自己写==>可以深拷贝
运算符重载,日期类练习,代码优化
频繁使用,放类里,inline,注意inline定义和声明不能分离
函数栈帧创建,变量创建和销毁顺序
```


# learn_9
第9周学习:C++和Linux

### C++:
- 1.日期类实现:运算符重载,构造,析构,拷贝构造,赋值重载;
函数复用
- 2.日期类完善:<<,>>运算符重载,友元函数/类,const修饰成员函数(*this);
```
static静态成员,静态成员函数,初始化列表(成员变量定义位置),内置类;
匿名对象,(变长数组:>待学习),隐式类型转化,explicit取消隐式类型转化
编译器优化:例如,函数值返回的临时变量有接受者,优化掉临时变量;
```
- 3.cpp链表实现
- 4.Oj作业练习
- 5.内存管理学习,malloc free ; new delete ; new [] delete[] ; 定位new,内存池;
- 6.模板,template<class T>;
- 7.STL: string学习
- 8.数据结构初阶考试,这让我认识到笔记很重要,遗忘中重复,重复中升华;
可以不用堆很多笔记在一次写完,明白一个知识点就写一个知识点的笔记,之后就是整理;
- 9.计数排序

### Linux:
- 1.shell外壳程序,权限:chmod,chown,chgrp,文件类型,umask,粘滞位 +t
- 2.vim使用
- 3.gcc g++ 动态/静态库 .so/.a .dll/.lib -static
- 4.make Makefile 依赖关系/方法
- 5.yum,git使用
- 6.进程,操作系统


# learn_10
第10周的学习

- 1.模板学习template<typename T>  template<class T>
- 2.STL学习,string		
- 3.string练习题:
```
字符串相加/相乘;第一个只出现一次字符串;翻转字符串1/2/3; 
 string模拟实现1/2 ; 注意if()不同类型比较类型转化问题,eg:size_t > int ==> size_t
 string模拟实现1/2/3; end = _size + 1; if(pos < end);可以解决当pos=0,end越界的问题,类型size_t
 s.get()可以读取缓冲区' '和'\0';但是>>不能;cout<<s可以答应'\0'后面的字符,C_str不能;
不要轻易缩容,缩容代价比较大
```

- 4.vector学习	
```
vector学习1 使用,模拟实现,迭代器失效问题
vector学习1/2 模拟实现,vector<vector<int>>,深浅拷贝问题
vector学习1/2/3 模拟实现
list学习1
list学习1/2 模拟实现	迭代器实现,对原生指针的封装,实现想要的运算符重载功能
stack/queue学习1  适配器

vector,list增加了反向迭代器适配器实现,但是有bug:const_reverse_iterator有问题,原因未知
debug:	
原因:reverse_iterator类型已经被重定义了,现在是reverse_iterator<iterator, T&, T*>,所以使用模板报错
修改:将reverse_iterator类名改为Reverse_iterator
const对象返回const_iterator,所以需要用const_iterator接受
总结:模板类名和tepedef后的类型名最好不同,否则分不清容易弄错
typedef Reverse_iterator<const_iterator,const T&,const T*> const_reverse_iterator;
```

### linux笔记整理 
- 1.基础指令
- 2.linux虚拟地址空间学习,进程控制学习
退出码,信号学习
fork()+wait()
- 进程退出三种情况:
```
1.进程跑完,结果正确(退出码0).
2.进程跑完,结果错误(退出码非0,对应错误原因).
3.进程崩溃.(退出码无效,程序被操作系统利用信号Kill,有退出信号);
```


# learn_11
第11周的学习(C++算入门了吧)

### C++
- 1.优先级队列学习;priority_queue 本质是容器适配器(适配器模式)堆,默认是大堆,仿函数默认less; 
priority_queue模拟实现;建堆的时间复杂度O(N),向上/下调整算法时间复杂度O(logN);
- 2.仿函数(函数对象)学习,本质是类对象重载operator()(参数),有点像函数;
- 3.双端队列学习,有list和vector的优点,但是不够极致,一般作为stack和queue底层容器,一般只头插头删,尾插尾删
- 4.反向迭代器实现:迭代器适配器,分装正向迭代器实现,底层不同的正向迭代器也能实现,但是要支持双向
- 5.写了一点之前的作业
- 6.模板进阶，继承，多态学习
- 7.模板进阶，继承，多态练习使用
- 8.很浅层次的Imgui学习,尝试了一下可视化窗口绘制
- 9.二叉搜索树学习,递归和非递归写法. Node*& root 的妙用.可以直接赋值
- 10.二叉树oj题目练习1, 层序遍历,非递归写法,利用其中前/中/后中两个排序构建二叉树
注意二维数组时,vector使用.resize()扩容,需要初始化元素
vector<vector<int>> v;
v.resize(3) ==>v.resize(3,vector<int>())
- 11.二叉树oj题目练习2, 二叉树转链表,stack记录路径,快速排序切分区间思想,左节点和右子树的子问题思想
- 12.map/set学习,AVL树学习
迷宫问题学习(递归需要训练,要话递归展开图),二叉搜索树博客撰写

### 数值计算算法实现：
- 1.实现了拉格朗日插值算法
- 2.实现了牛顿插值算法
- 3.牛顿插值算法优化
- 4.最小二乘法模拟实现
- 5.龙贝格积分算法模拟实现
- 6.一阶常微分求解,四阶龙格-库塔算法



# learn_12
第12周的学习

- 1. AVL树学习1,迷宫问题学习,迷宫问题&最优路径编程实现
- 2. AVL树学习2,左单旋,右单旋,RL双旋,LR双旋; AVL树实现
- 3. 红黑树学习1/2,红黑树封装为set/map学习; 哈希学习1
- 4. 红黑树学习3,红黑树实现  bug:红黑树的拷贝构造编译失败?
- 5. 红黑树学习4,红黑树适配set/map的调整,迭代器实现; 封装红黑树为set/map
模板运用; STL源码剖析学习
- 6. 哈希表学习2; 哈希表封装map/set实现
- 7. 位图bitset;布隆过滤器;哈希切割;C++11部分语法:{}; initializer_list; decltype; {}初始化一切;
- 8. 左值引用&,右值引用&& (转移资源),move(),完美转发forward<T>(), 
关键字 = defalut; = delete; 新增类的2个默认构造,移动构造,移动赋值;
可变模板参数; template<class ...Args> func(Args... args); 解析参数的方法; emplace插入接口,
- 9. bitset模拟实现1, 布隆过滤器模拟实现1/2(计数布隆过滤器)
bitset练习,哈希切割文件实现,海量数据处理练习
- 10. C++11语法练习1/2: 
右值引用,完美转发,移动构造,移动赋值,decltype,default,delete,final,override学习;
可变模板参数学习

- 11. 我尝试了一下GPT QQ机器人的布置,没有成功;
起初,我花了半天升级服务器相关软件,最后glibc升级失败,手动安装 -- 这时,我想到了语言的跨平台性.
运行程序,反向代理弄了,但是效果并不好,缺乏相关知识,乏力.	-- 需要学习网络知识
程序基于python3.9, 没有python基础和大型项目构建经验,乏力	-- 需要大型项目实战,python基础

- 12.linux学习:文件系统,进程通讯.C++11的学习到了线程库,所以我打算先学到linux线程部分再继续.
锁,CAS(硬件同步原语),原子操作, c++ lambda学习



# learn_13
这不是第13周，但是沿用了之前的命名风格

### 数据结构学习
- 并查集，图学习1/2/3, LRUcache学习
- B树学习: B树的插入实现,细节很多
- 跳表学习
- 数据结构学习告一段落 -> 接下来就是应用：mySQL
tips: 我code慢,很大程度上因为没有在纸上缕清楚细节,得改

### 优选算法学习
- 二分查找
- 前缀和
- 位运算
- 模拟
- 分治:归并(逆序数),快速选择算法
- 链表:头插逆置,快慢指针
- 递归/搜索/回溯: 
```
递归宏观视角(黑盒子),树的视角,循环与递归的相似:子问题
函数头, 函数体, 细节: 剪枝,递归出口,回溯; 全局变量; 决策树
排列, 组合
剪枝: 减少决策树的熵,初始不确定性
决策树- hash, N皇后,数独,迷宫路径
floodFill算法
带备忘录的递归(剪枝) -> 记忆化搜索 -> 动态规划 
```

### MySQL学习
- 1.mysql安装,数据库和表的创建/修改/查询/删除,数据库变量类型;

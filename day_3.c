#define _CRT_SECURE_NO_WARNINGS

//【题目名称】
//杨辉三角
//【题目内容】
//在屏幕上打印杨辉三角。
//1
//1 1
//1 2 1
//1 3 3 1
//……
#include <stdio.h>

////1.0
//void init(int arr[],int tmp[], int line)
//{
//	arr[0] = 1;
//	arr[line - 1] = 1;
//	int i = 0;
//	for (i = 1; i < line - 1; i++)
//	{
//		arr[i] = tmp[i - 1] + tmp[i];
//	}
//
//}
//
//int main()
//{
//	int i = 0;
//	int j = 0;
//	int arr[100] = { 0 };
//	int tmp[100] = { 0 };
//	int* parr = arr;
//	int* ptmp = tmp;
//	int line = 0;
//	scanf("%d", &line);//打印多少行
//	for (i = 0; i <= line; i++)
//	{
//		//存储上一次的值
//		for (int n = 0; n < line; n++)
//		{
//			tmp[n] = arr[n];
//		}
//		for (int j = 0; j < i; j++)
//		{
//
//			init(arr, tmp, line);//初始化arr
//			//打印前置空格
//
//			//打印杨辉三角数字
//			printf("%2d ", arr[j]);
//		}
//		printf("\n");
//	}
//	return 0;
//}


////2.0	代码优化
//void init(int arr[], int line)
//{
//	arr[0] = 1;
//	arr[line - 1] = 1;
//	int i = 0;
//	for (i = line - 2; i > 0; i--)//反着来,不用创建临时数组
//	{
//		arr[i] = arr[i] + arr[i - 1];
//	}
//}
//int main()
//{
//	int arr[100] = { 0 };//只存储最新一行
//	int line = 0;
//	scanf("%d", &line);
//	int i = 0;
//	for (i = 1; i <= line; i++)
//	{
//		init(arr, i);//初始化
//		int j = 0;
//		for (j = 0; j < i; j++)
//		{
//			printf("%2d ", arr[j]);
//		}
//		printf("\n");
//	}
//	return 0;
//}

////3.0	代码拓展

//int main()
//{
//	int arr[50][50] = {0};//创建一个二位数组存储每行每列
//	int line = 0;
//	scanf("%d", &line);
//	int i = 0;//行
//	int j = 0;//列
//	for (i = 1; i <= line; i++)
//	{
//		arr[i][0] = 1;
//		arr[i][i - 1] = 1;
//		int n = 0;
//		for (n = i - 2; n > 0; n--)
//		{
//			arr[i][n] = arr[i-1][n] + arr[i-1][n - 1];
//		}
//
//		for (j = 0; j < i; j++)
//		{
//			printf("%2d ", arr[i][j]);
//		}
//		printf("\n");
//	}
//	return 0;
//}


//【题目名称】
//猜凶手
//【题目内容】
//日本某地发生了一件谋杀案，警察通过排查确定杀人凶手必为4个嫌疑犯的一个。
//以下为4个嫌疑犯的供词:
//A说：不是我。
//B说：是C。
//C说：是D。
//D说：C在胡说
//已知3个人说了真话，1个人说的是假话。
//现在请根据这些信息，写一个程序来确定到底谁是凶手。
#include <stdio.h>

//1.0
////四个人
//int a = 0;
//int b = 1;
//int c = 2;
//int d = 3;
//
////结果真假数量
//int anwser(int arr[])
//{
//	int yes = 0;
//	if (arr[a] == 0)//A真
//		yes++;
//	if (arr[c] == 1)//B真
//		yes++;
//	if (arr[d] == 1)//C真
//		yes++;
//	if (arr[d] != 1)//D真
//		yes++;
//	return yes;
//}
//int main()
//{
//
//	int arr[4] = { 0 };
//	int truth = 0;
//	int i = 0;
//	for (i = 0; i < 4; i++)
//	{
//		arr[i] = 1;
//		
//		//结果真假数量
//		truth = anwser(arr);
//		if (truth == 3)//总数为4,有三个真,必有一个假.
//		{
//			switch (i)
//			{
//			case 0:
//				printf("A是凶手.\n");
//				break;
//			case 1:
//				printf("B是凶手.\n");
//				break;
//			case 2:
//				printf("C是凶手.\n");
//				break;
//			case 3:
//				printf("D是凶手.\n");
//				break;
//			}
//
//		}
//		//置为0
//		int j = 0;
//		for (j = 0; j < 4; j++)
//		{
//			arr[j] = 0;
//		}
//	}
//	return 0;
//}

//2.0	代码优化
//int main()
//{
//	int killer = 0;
//	for (killer = 'A'; killer <= 'D'; killer++)
//	{
//		if (((killer != 'A') + (killer == 'C') + (killer == 'D') + (killer != 'D')) == 3)//结果为真,返回1,为假返回0
//			printf("%c 是凶手\n", killer);
//	}
//}


//请简述大端字节序和小端字节序的概念，设计一个小程序来判断当前机器的字节序。（10分）
//答:计算机存储的数据类型有超过1个类型,比如short,int 分别对应2,4字节.不同编译器有差异.
//超过一个字节的内容需要拆开存入到每个字节中,就涉及到拆开顺序.
//大端字节序,高字节序的内容存储到低地址位,低字节序内容存储到高地址位.
//小端字节序,低字节序的内容存储到低地址位,高字节序内容存储到高地址位.
#include <stdio.h>

//int main()
//{
//	//int a = 0x00000001;
//	int a = 1;
//	char* p = &a;
//	if (*p == 1)
//		printf("小端字节序.\n");
//	else
//		printf("大端字节序.\n");
//
//	return 0;
//}


//数据存储练习

//1.
//输出什么？
#include <stdio.h>
//int main()
//{
//    char a = -1;//char 此编译器默认是 signed char
//    //10000000000000000000000000000001原码    
//    //11111111111111111111111111111110反码
//    //11111111111111111111111111111111补码
//    //11111111截断后面 8bit
//
//    signed char b = -1;
//    //10000000000000000000000000000001原码    
//    //11111111111111111111111111111110反码
//    //11111111111111111111111111111111补码
//    //11111111截断后面 8bit
//
//    unsigned char c = -1;
//    //10000000000000000000000000000001原码    
//    //11111111111111111111111111111110反码
//    //11111111111111111111111111111111补码
//    //11111111截断后面 8bit     这里unsigned ,所以首位1不是符号位
//
//    printf("a=%d,b=%d,c=%d", a, b, c);
//    //%d 按照10进制打印,4个字节
//    //整形提升,按照符号位补位,无符号位补 0 
//    //a
//    //11111111补码
//    //11111111111111111111111111111111补位后补码
//    //11111111111111111111111111111110反码
//    //10000000000000000000000000000001原码    -1
//    
//    //b
//    //11111111补码
//    //11111111111111111111111111111111补位后补码
//    //11111111111111111111111111111110反码
//    //10000000000000000000000000000001原码    -1
//
//    //c
//    //11111111补码  unsigned char  无符号位补 0 
//    //00000000000000000000000011111111补位后补码
//    //00000000000000000000000011111111  %d看待内存的视角,int ,正数,原反补相同 2^8-1 = 255
//
//    return 0;
//}
//总结:看待内存的视角


//2.
#include <stdio.h>
//int main()
//{
//    char a = -128;
//    //10000000000000000000000010000000
//    //11111111111111111111111101111111
//    //11111111111111111111111110000000
//    //10000000  按照char 8bit截断后
//
//    printf("%u\n", a);
//    //a
//    //10000000补码    signed 补1   整形提升
//    //11111111111111111111111110000000补码
//    //%u 看待内存视角, unsigned,没有符号位,原反补相同   对应10进制 4,294,967,168
//
//    return 0;
//}


//3.
#include <stdio.h>
//int main()
//{
//    char a = 128;
//    //00000000000000000000000010000000  原,反,补码相同
//    //10000000  按照char 8bit截断后
//
//    printf("%u\n", a);
//    //a
//    //10000000补码    signed 补1   整形提升
//    //11111111111111111111111110000000补码
//    //%u 看待内存视角, unsigned,没有符号位,原反补相同   对应10进制 4,294,967,168
//
//    return 0;
//}


////4.
//int main() 
//{
//	int i = -20;
//	//10000000000000000000000000010100
//	//11111111111111111111111111101011
//	//11111111111111111111111111101100
//
//	unsigned  int  j = 10;
//	//00000000000000000000000000001010	原,反,补码相同
//	
//	printf("%d\n", i + j);
//	//按照补码的形式进行运算，最后格式化成为有符号整数
//	//不同类型数据计算,需要类型转换
//	//为寻常算术转换	由低到高
//	//long double
//	//double
//	//float
//	//unsigned long int
//	//long int
//	//unsigned int
//	//int
//	//其中 i转化位unsigned int 
//	//11111111111111111111111111101100	i	int  ->  unsigned int
//	//00000000000000000000000000001010	j	unsigned int
//	//11111111111111111111111111110110	i+j	unsigned int	对应10进制	4,294,967,286
//	//但是
//	//关键不是数据是什么类型,而是	看待内存的视角
//	//%d	看待内存的视角为 int ,signed
//	//11111111111111111111111111110110	补码	i+j
//	//11111111111111111111111111110101	反码
//	//10000000000000000000000000001010	原码	对应10进制 -10
//
//	return 0;
//}
////总结: 关键不是数据是什么类型,而是	看待内存的视角


////5.
//int main()
//{
//	unsigned int i;
//	for (i = 9; i >= 0; i--)//无限循环
//	{
//		printf("%u\n", i);
//	}
//	return 0;
//}


////6.
//int main()
//{
//    char a[1000];
//    int i;
//    for (i = 0; i < 1000; i++)
//    {
//        a[i] = -1 - i;
//    }
//    printf("%d", strlen(a));
//    //char 范围 -128~127
//    //-1 -2 ...-128 127 126 ... 2 1 0
//    //0 ASCII '\0'
//    //255
//    return 0;
//}


////7.
//#include <stdio.h>
//unsigned char i = 0;    // 0~255
////int m;//全局变量未初始化,默认为 0
//int main()
//{
//    //printf("%d\n", m);//0
//
//    for (i = 0; i <= 255; i++)//死循环
//    {
//        printf("hello world\n");
//    }
//    return 0;
//}


////浮点数
#include <stdio.h>
//int main()
//{
//	//IEEE（电气和电子工程协会） 754 规定任意一个二进制浮点数V可以表示成下面的形式
//	//浮点数可以表示为
//	//(-1) ^ S* M * 2 ^ E
//	//(-1) ^ s表示符号位，当s = 0，V为正数；当s = 1，V为负数。
//	//M表示有效数字，大于等于1，小于2。
//	//2 ^ E表示指数位。
//	//对于32位的浮点数，最高的1位是符号位s，接着的8位是指数E，剩下的23位为有效数字M。
//	//对于64位的浮点数，最高的1位是符号位S，接着的11位是指数E，剩下的52位为有效数字M。
//	//存入内存时E的真实值必须再加上一个中间数，对于8位的E，
//	//这个中间数是127；对于11位的E，这个中间数是1023
//	//E全为0	这时，浮点数的指数E等于1 - 127（或者1 - 1023）即为真实值，
//  //E全为1	这时，如果有效数字M全为0，表示±无穷大（正负取决于符号位s）；
//
//	int n = 9;
//	//00000000000000000000000000001001
//
//	float* pFloat = (float*)&n;//64位,64bit
//	printf("n的值为：%d\n", n);
//	//00000000000000000000000000001001	%d	9
//	printf("*pFloat的值为：%f\n", *pFloat);
//	//0 00000000 00000000000000000001001	%f
//	//s E		 m		E全0,e = 0-127,m = 0.xxxxx
//	//(-1)^0*2^(-127)*(0.00000000000000000001001这里是二进制表示)	约等于0
//
//	*pFloat = 9.0;
//	//1001.0 = 1.001*2^3	m = 1.001	e = 3 + 127 = 130
//	//s		e		m(1.省略,只留下小数点后面)
//	//0	10000010	00100000000000000000000
//
//	printf("num的值为：%d\n", n);
//	//n	看待内存视角 %d	int
//	//0 10000010 00100000000000000000000	原反补相同	对应10进制	1,091,567,616
//
//	printf("*pFloat的值为：%f\n", *pFloat);
//	//n
//	//0	10000010	00100000000000000000000
//	//s	e			m		e = e -127 = 130 -127 = 3
//	// n = (-1)^s*m*2^e		9.0
//	return 0;
//}


//【题目名称】
//猜名次
//【题目内容】
//5位运动员参加了10米台跳水比赛，有人让他们预测比赛结果：
//A选手说：B第二，我第三；
//B选手说：我第二，E第四；
//C选手说：我第一，D第二；
//D选手说：C最后，我第三；
//E选手说：我第四，A第一；
//比赛结束后，每位选手都说对了一半，请编程确定比赛的名次。
#include <stdio.h>
#include <time.h>

////有问题,不对
//int main()
//{
//	int a = 0, b = 1, c = 2, d = 3, e = 4;
//	char ranking[5] = { 0 };
//	
//	while (1)
//	{
//		while (1)//随机次序
//		{
//			ranking[a] = rand() % 5 + 1;//1~5
//			if ((ranking[b] = (rand() % 5 + 1)) != ranking[a])
//				if ((ranking[c] = (rand() % 5 + 1)) != ranking[a] && (ranking[c] = (rand() % 5 + 1)) != ranking[b])
//					if ((ranking[d] = (rand() % 5 + 1)) != ranking[a] && (ranking[d] = (rand() % 5 + 1)) != ranking[b] && (ranking[d] = (rand() % 5 + 1)) != ranking[c])
//						if ((ranking[e] = (rand() % 5 + 1)) != ranking[a] && (ranking[e] = (rand() % 5 + 1)) != ranking[b] && (ranking[e] = (rand() % 5 + 1)) != ranking[c] && (ranking[e] = (rand() % 5 + 1)) != ranking[d])
//							break;
//		}
//		//检验真伪
//		if ((ranking[b] == 2) + (ranking[a] == 3) == 1	 //A
//			&& (ranking[b] == 2) + (ranking[e] == 4) == 1//B
//			&& (ranking[c] == 1) + (ranking[d] == 2) == 1//C
//			&& (ranking[c] == 5) + (ranking[d] == 3) == 1//D
//			&& (ranking[e] == 4) + (ranking[a] == 1) == 1)//E
//			break;
//	}
//
//	//打印
//	printf("a  b  c  d  e  \n");
//	int i = 0;
//	for (i = 0; i < 5; i++)
//	{
//		printf("%d ", ranking[i]);
//	}
//	printf("\n");
//	return 0;
//}

//有问题,不对
//int main()
//{
//	int a = 0, b = 1, c = 2, d = 3, e = 4;
//	char ranking[5] = { 0 };
//
//	while (1)
//	{
//		//随机	二选一
//		if (rand() % 2 == 1)//a
//			ranking[b] = 2;
//		else
//			ranking[a] = 3;
//		if (rand() % 2 == 1)//b
//			ranking[b] = 2;
//		else
//			ranking[e] = 4;
//		if (rand() % 2 == 1)//c
//			ranking[c] = 1;
//		else
//			ranking[d] = 2;
//		if (rand() % 2 == 1)//d
//			ranking[c] = 5;
//		else
//			ranking[d] = 3;
//		if (rand() % 2 == 1)//e
//			ranking[e] = 4;
//		else
//			ranking[a] = 1;
//		//判断	名次不重复
//		int i = 0;
//		int count = 0;
//		for (i = 0; i < 5; i++)
//		{
//			int j = 0;
//			for (j = 0;( j < 5 && j != i); j++)
//			{
//				if (ranking[i] == ranking[j] || ranking[i] == 0)
//					count++;
//			}
//		}
//		if (count == 0)
//			break;
//		count = 0;
//	}
//
//	//打印
//	printf("a  b  c  d  e  \n");
//	int i = 0;
//	for (i = 0; i < 5; i++)
//	{
//		printf("%d ", ranking[i]);
//	}
//	printf("\n");
//	return 0;
//}


//参考代码
#include <stdio.h>

int checkData(int* p)
{
	int tmp[7] = { 0 }; //标记表，实际是哈希表的思路。一开始每个元素都是0。

	int i;
	for (i = 0; i < 5; i++)
	{
		if (tmp[p[i]]) //如果这个位置的标记已经是1，则代表重复，直接返回0。
		{
			return 0;
		}
		tmp[p[i]] = 1; //如果不是，则给这个位置标记为1。
	}
	return 1; //全部标记完毕也没有出现重复的情况，代表OK。
}

int main()
{
	int p[5]; //0 1 2 3 4分别代表a b c d e

	for (p[0] = 1; p[0] <= 5; p[0]++)
	{
		for (p[1] = 1; p[1] <= 5; p[1]++)
		{
			for (p[2] = 1; p[2] <= 5; p[2]++)
			{
				for (p[3] = 1; p[3] <= 5; p[3]++)
				{
					for (p[4] = 1; p[4] <= 5; p[4]++) //五层循环遍历
					{
						//这里是五个人的描述，由于比较表达式只有0和1两个结果，如果要两个条件有且只有一个为真，则可以用比较表达式的值总和为1的方式直接判定。别忘了还要判定不能并列。
						if ((p[1] == 2) + (p[0] == 3) == 1 && //B第二，我第三
							(p[1] == 2) + (p[4] == 4) == 1 && //我第二，E第四
							(p[2] == 1) + (p[3] == 2) == 1 && //我第一，D第二
							(p[2] == 5) + (p[3] == 3) == 1 && //C最后，我第三
							(p[4] == 4) + (p[0] == 1) == 1 && //我第四，A第一
							checkData(p) //不能并列
							)
						{
							for (int i = 0; i < 5; i++)
							{
								printf("%d ", p[i]);
							}
							putchar('\n');
						}
					}
				}
			}
		}
	}

	return 0;
}

//此题未完成